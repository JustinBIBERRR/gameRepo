# Design: 听片段猜电影游戏

## 架构概述

电影猜测游戏分为以下几个主要部分：
1. **电影数据管理**：存储电影信息和视频资源
2. **视频/音频播放器**：支持指定时间点播放和音频提取
3. **时间点选择器**：用户输入时间点（分钟:秒）
4. **游戏逻辑**：随机选择电影、猜测验证、历史记录
5. **回顾功能**：游戏结束后查看所有选择的视频片段

## 组件设计

### 1. MovieGuess.vue 主游戏页面
- **路由**：`/movie-guess`
- **功能**：
  - 显示游戏说明和规则
  - 显示倒计时和进度条
  - 显示时间点选择器
  - 显示音频播放器（猜测阶段）
  - 显示猜测输入框（电影名称）
  - 显示猜测历史记录
  - 游戏结束后显示回顾功能（视频片段列表）
- **布局**：
  - 顶部：游戏标题、倒计时、进度条
  - 中间：时间点选择器、播放器区域
  - 底部：猜测输入、历史记录

### 2. VideoPlayer 组件
- **功能**：
  - 播放本地视频文件（通过 File 对象或 Object URL）
  - 支持跳转到指定时间点（使用 video.currentTime）
  - 支持只播放音频模式（CSS隐藏视频画面）
  - 支持播放指定时长的片段（如15秒，使用定时器控制）
  - 支持显示/隐藏视频画面（猜测时隐藏，回顾时显示）
- **Props**：
  - `videoFile`: File对象或Object URL
  - `startTime`: 开始时间（秒）
  - `duration`: 播放时长（秒，默认15秒）
  - `audioOnly`: 是否只播放音频（默认false，隐藏画面）
  - `autoPlay`: 是否自动播放（默认false）
- **方法**：
  - `play()`: 播放
  - `pause()`: 暂停
  - `seek(time)`: 跳转到指定时间（设置 currentTime）

### 3. TimeSelector 组件
- **功能**：
  - 提供时间轴拖拽选择（快速定位）
  - 提供数字输入（分钟:秒格式，精确到秒）
  - 验证时间范围（不能超过电影总时长）
  - 格式化显示（如：55分20秒）
  - 实时同步：拖拽和输入双向同步
- **Props**：
  - `maxDuration`: 最大时长（秒，根据电影总时长）
  - `value`: 当前选择的时间点（秒）
- **Events**：
  - `@change`: 时间点改变事件（返回秒数）

### 4. 电影数据结构
```typescript
interface Movie {
  id: string
  name: string
  nameVariants: string[]  // 别名，用于匹配猜测
  duration: number        // 总时长（秒）
  description?: string    // 电影描述（可选）
  year?: number           // 上映年份（可选）
}

interface VideoSegment {
  startTime: number       // 片段在电影中的开始时间（秒）
  duration: number        // 片段时长（秒，通常15秒）
  audioFile: File         // 音频文件（MP3）
  videoFile: File         // 视频文件（MP4）
}

interface VideoSegment {
  startTime: number       // 片段在电影中的开始时间（秒）
  duration: number        // 片段时长（秒，通常15秒）
  audioFile: File         // 音频文件（MP3）
  videoFile: File         // 视频文件（MP4）
}

interface LocalMovieFiles {
  movieId: string
  keySegments?: VideoSegment[]  // 关键片段数组（快速路径，可选）
  sourceFile?: File            // 原文件（精确路径，可选）
  sliceInterval?: number       // 切片间隔（秒，如300表示每5分钟一个片段）
  playbackMode?: 'fast' | 'precise' | 'auto'  // 播放模式
  selectedAt: number           // 选择时间戳
}
```

## 数据流

1. **游戏开始流程**：
   - 系统随机选择一部电影
   - 从设置中读取最大尝试次数（默认8次）
   - 初始化游戏状态（尝试次数、历史记录等）
   - 启动倒计时

2. **猜测流程**：
   - 用户通过时间轴拖拽或数字输入选择时间点
   - 用户点击"播放音频"按钮
   - 系统检查该时间点的播放次数是否已达上限（从设置中读取）
   - 如果未达上限，系统从指定时间点开始播放15秒音频（不显示视频）
   - 播放次数+1，记录到该时间点的播放历史
   - 用户根据听到的音频猜测电影名称
   - 用户输入电影名称并提交
   - 系统验证猜测是否正确（精确匹配 + 预设别名 + 模糊匹配）
   - 如果正确，游戏成功；如果错误，记录到历史并继续

3. **游戏结束流程**：
   - 如果猜对或尝试次数用尽，游戏结束
   - 显示游戏结果（成功/失败）
   - 显示回顾功能：列出所有猜测历史，每个历史项可点击查看对应的视频片段（15秒）

## 存储设计

### localStorage 键
- `movieGameStats`: 电影游戏统计数据（复用现有GameStats接口）
- `gameSettings`: 游戏设置（扩展，添加movie游戏类型配置）
  ```typescript
  {
    defaults: { ... },
    overrides: {
      movie: {
        timerDuration?: number,
        maxAttempts?: number,
        showInitialHint?: boolean,
        maxPlaybackPerSegment?: number  // 每个片段最多播放次数，默认值待定
      }
    }
  }
  ```

### IndexedDB 存储
- `movieFiles`: 本地电影文件配置
  ```typescript
  {
    movieId: string,
    file: File,              // File对象
    fileName: string,
    fileSize: number,
    lastModified: number,
    selectedAt: number
  }
  ```

### sessionStorage 键
- `movieGuessGame`: 当前游戏状态
  ```typescript
  {
    targetMovie: string,        // 目标电影ID
    attempts: number,           // 已尝试次数
    playbackHistory: Map<number, number>,  // 每个时间点的播放次数 {timePoint: count}
    guessHistory: Array<{      // 猜测历史
      timePoint: number,        // 选择的时间点（秒）
      movieName: string,        // 猜测的电影名称
      isCorrect: boolean        // 是否正确
    }>,
    gameOver: boolean,
    gameWon: boolean,
    gameStartTime: number
  }
  ```

## 技术实现细节

### 视频播放实现（混合方案）

**快速模式（关键片段）**：
- 使用HTML5 `<video>` 元素加载15秒视频片段
- 片段文件小（50-200MB），加载快（1-3秒）
- 通过 File API 读取切片文件，创建 Object URL

**精确模式（原文件）**：
- 使用HTML5 `<video>` 元素加载原文件（30GB）
- 使用 `preload="metadata"` 快速加载元数据（<2秒）
- 使用 `video.currentTime` 跳转到目标时间点
- 浏览器自动使用Range请求按需加载
- 监听 `canplay` 事件，当有足够数据时开始播放（30秒内）
- 显示加载进度和预计时间

**通用功能**：
- 音频模式（猜测阶段）：使用CSS `display: none` 隐藏视频画面
- 视频模式（回顾阶段）：正常显示视频画面
- 播放15秒：使用 `setTimeout` 或监听 `timeupdate` 事件在15秒后暂停
- 创建 Object URL：`const objectUrl = URL.createObjectURL(file)`，使用后释放
- **加载状态**：显示加载提示和进度条

### 智能播放模式选择

**自动模式**（推荐）：
- 用户选择时间点
- 如果时间点接近关键片段（±2.5分钟），使用关键片段（快速）
- 否则使用原文件跳转（精确，30秒内）

**用户选择模式**：
- 提供"快速模式"和"精确模式"选项
- 快速模式：只使用关键片段，时间点可能偏离
- 精确模式：使用原文件，完全精确，需要等待

### 时间点选择实现
- **时间轴拖拽**：
  - 使用HTML5 range input或自定义滑块组件
  - 显示电影总时长作为参考
  - 拖拽时实时更新显示的时间点（分钟:秒格式）
  - 支持快速定位到任意时间点
- **数字输入**：
  - 使用两个输入框：分钟和秒数
  - 验证：总秒数不能超过电影总时长
  - 格式化：将分钟和秒数转换为总秒数
- **双向同步**：
  - 拖拽时间轴时，数字输入框自动更新
  - 修改数字输入时，时间轴滑块自动更新位置

### 电影名称匹配
- **精确匹配**：完全匹配电影名称
- **预设别名匹配**：匹配电影数据中定义的别名列表（如"哪吒"匹配"哪吒之魔童降世"）
- **模糊匹配**：
  - 忽略大小写
  - 忽略空格和标点符号
  - 支持部分匹配（如"魔童降世"匹配"哪吒之魔童降世"）
- **匹配优先级**：精确匹配 > 预设别名 > 模糊匹配

## 边界情况处理

1. **视频加载失败**：
   - 显示错误提示
   - 允许用户重新选择时间点

2. **时间点超出范围**：
   - 验证时间点不能超过电影总时长
   - 如果选择的时间点+15秒超过总时长，自动调整播放时长

3. **浏览器不支持视频格式**：
   - 检测浏览器支持的视频格式
   - 提供多种格式的视频文件（MP4、WebM等）

4. **音频播放失败**：
   - 显示错误提示
   - 允许用户重新播放

## UI/UX 考虑

1. **播放器设计**：
   - 音频模式：显示音频波形或占位图
   - 视频模式：显示视频画面
   - 播放控制：播放/暂停按钮、进度条

2. **时间点选择**：
   - 时间轴拖拽：直观的滑块界面，快速定位
   - 数字输入：精确到秒的输入框（分钟:秒格式）
   - 双向同步：拖拽和输入实时同步
   - 实时验证和提示
   - 显示电影总时长作为参考

3. **回顾功能**：
   - 游戏结束后显示历史记录列表
   - 每个历史项显示：时间点、猜测的电影名称、是否正确
   - 点击历史项可播放对应的视频片段（15秒，显示视频）

## 性能考虑

1. **视频加载优化**：
   - **必须使用切片**：30GB+文件直接使用会导致跳转时间过长（10-60秒）
   - 使用15秒视频片段（50-200MB），加载快（1-3秒）
   - 用户选择时间点时，找到最接近的切片片段
   - 显示加载状态和进度提示

2. **切片策略**：
   - **关键片段切片**（推荐）：每5-10分钟一个片段，总大小600MB-4.8GB
   - **完整切片**（可选）：每15秒一个片段，总大小24-96GB（存储空间大）
   - 提供FFmpeg脚本，用户预处理一次即可

3. **内存管理**：
   - 播放完音频后及时释放 Object URL：`URL.revokeObjectURL(objectUrl)`
   - 避免同时加载多个视频片段
   - 浏览器自动缓存已加载的片段

4. **用户体验优化**：
   - 片段加载完成后立即显示时间点选择器
   - 加载片段时显示加载提示："正在加载视频片段..."
   - 播放开始时显示播放进度
   - 如果用户选择的时间点没有对应片段，选择最接近的片段并提示

## 电影数据准备

### 电影列表（示例）
- 哪吒之魔童降世（2019）
- 无间道（2002）
- 我不是药神（2018）
- 战狼2（2017）
- 流浪地球（2019）
- 红海行动（2018）
- 唐人街探案（2015）
- 夏洛特烦恼（2015）
- 等等...

### 视频资源策略

**本地文件方案（主要方案）**
- 用户在设置页面为每部电影选择本地视频文件（MP4格式）
- **重要**：由于电影文件通常很大（30GB+），直接使用会导致跳转时间过长（10-60秒）
- **解决方案**：必须使用视频切片，将视频预处理成15秒片段
- 用户选择本地文件后，系统自动识别是否已切片
- 如果未切片，提示用户使用FFmpeg脚本预处理
- 使用 File API 读取切片文件
- 使用 IndexedDB 存储 File 对象，下次访问时自动加载
- 优点：零存储成本，用户使用自己的资源，版权安全，加载速度快
- 实现：File API + IndexedDB + HTML5 video元素 + 视频切片

**视频资源策略（混合方案）**：

- **方案A：关键片段 + 精确时间点混合**（推荐）⭐⭐⭐⭐
  - **关键片段**（快速路径）：
    - 每5-10分钟切一个15秒片段
    - 加载时间：1-3秒
    - 用户选择时间点接近关键片段（±2.5分钟）时，使用关键片段
  - **精确时间点**（精确路径）：
    - 保留原文件（30GB）
    - 使用Range请求按需加载
    - 使用 `preload="metadata"` 快速加载元数据（<2秒）
    - 跳转到目标时间点时，浏览器自动使用Range请求加载对应部分
    - 显示加载进度，30秒内可以开始播放（边加载边播放）
    - 支持完全精确的时间点选择
  - **智能选择**：
    - 默认使用关键片段（快速）
    - 用户可以选择"精确模式"使用原文件（30秒内）
    - 或者：自动判断，接近关键片段用片段，否则用原文件

- **方案B：仅关键片段切片**
  - 每5-10分钟切一个15秒片段
  - 总大小：600MB-4.8GB
  - 优点：存储空间合理，加载快
  - 缺点：时间点选择受限（只能选择关键片段附近）

**音频播放实现**：
- 使用 HTML5 `<video>` 元素加载15秒视频片段（不是完整文件）
- 通过 CSS `display: none` 或 `visibility: hidden` 隐藏视频画面
- 只播放音频，不显示画面
- 片段文件小（50-200MB），加载快（1-3秒）
- 使用 `setTimeout` 控制播放时长（15秒后自动暂停）

**视频播放实现（回顾阶段）**：
- 使用同一个 `<video>` 元素加载对应的视频片段
- 回顾时显示视频画面（移除CSS隐藏）
- 播放15秒视频片段

**时间点跳转实现（混合方案）**：

1. **快速模式（使用关键片段）**：
   - 用户选择时间点（如55分20秒 = 3320秒）
   - 系统找到最接近的关键片段（如55分钟 = 3300秒）
   - 如果时间差≤2.5分钟，使用关键片段（1-3秒加载）
   - 播放15秒片段

2. **精确模式（使用原文件）**：
   - 用户选择任意时间点（如55分20秒 = 3320秒）
   - 系统使用原文件（30GB）
   - 使用 `video.currentTime = 3320` 跳转
   - 浏览器自动使用Range请求加载对应部分
   - 显示加载进度："正在跳转到55分20秒...（预计10-30秒）"
   - 当有足够数据可以播放时（`canplay`事件），自动开始播放
   - 通常在30秒内可以开始播放（边加载边播放）
   - 播放15秒后暂停

### 数据文件结构
```json
{
  "movies": [
    {
      "id": "nezha",
      "name": "哪吒之魔童降世",
      "nameVariants": ["哪吒", "哪吒之魔童降世", "魔童降世"],
      "duration": 6660,
      "year": 2019,
      "description": "国产动画电影，讲述哪吒的成长故事"
    },
    ...
  ]
}
```

**本地文件配置（存储在IndexedDB）**：
```typescript
interface LocalMovieFile {
  movieId: string
  file: File              // File对象（从IndexedDB读取）
  fileName: string        // 文件名（用于显示）
  fileSize: number        // 文件大小
  lastModified: number    // 文件最后修改时间
  selectedAt: number       // 选择时间戳
}
```

## 集成点

### 平台集成
- 在 `Home.vue` 中添加游戏卡片
- 在 `router/index.ts` 中添加路由
- 在 `Settings.vue` 中添加电影文件配置选项（为每部电影选择本地文件）

### 现有系统集成
- 复用倒计时系统（`useTimer` composable）
- 复用游戏统计系统（`storageUtils.ts`）
- 复用成就系统（`achievementUtils.ts`）
- 复用模态框系统（`useModal` composable）
